'use strict';
var $ = require('../internals/export');
var globalThis = require('../internals/global-this');
var call = require('../internals/function-call');
var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = require('../internals/typed-array-constructors-require-wrappers');
var ArrayBufferViewCore = require('../internals/array-buffer-view-core');
var ArrayBufferModule = require('../internals/array-buffer');
var anInstance = require('../internals/an-instance');
var createPropertyDescriptor = require('../internals/create-property-descriptor');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var isIntegralNumber = require('../internals/is-integral-number');
var toLength = require('../internals/to-length');
var toIndex = require('../internals/to-index');
var toOffset = require('../internals/to-offset');
var toUint8Clamped = require('../internals/to-uint8-clamped');
var toPropertyKey = require('../internals/to-property-key');
var hasOwn = require('../internals/has-own-property');
var classof = require('../internals/classof');
var isObject = require('../internals/is-object');
var isSymbol = require('../internals/is-symbol');
var isPrototypeOf = require('../internals/object-is-prototype-of');
var setPrototypeOf = require('../internals/object-set-prototype-of');
var typedArrayFrom = require('../internals/typed-array-from');
var forEach = require('../internals/array-iteration').forEach;
var setSpecies = require('../internals/set-species');
var defineBuiltInAccessor = require('../internals/define-built-in-accessor');
var definePropertyModule = require('../internals/object-define-property');
var getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');
var arrayFromConstructorAndList = require('../internals/array-from-constructor-and-list');
var InternalStateModule = require('../internals/internal-state');
var inheritIfRequired = require('../internals/inherit-if-required');

var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;
var enforceInternalState = InternalStateModule.enforce;
var create = Object.create;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
var RangeError = globalThis.RangeError;
var ArrayBuffer = ArrayBufferModule.ArrayBuffer;
var ArrayBufferPrototype = ArrayBuffer.prototype;
var DataView = ArrayBufferModule.DataView;
var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
var TYPED_ARRAY_TAG = ArrayBufferViewCore.TYPED_ARRAY_TAG;
var TypedArray = ArrayBufferViewCore.TypedArray;
var TypedArrayPrototype = ArrayBufferViewCore.TypedArrayPrototype;
var isTypedArray = ArrayBufferViewCore.isTypedArray;
var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
var WRONG_LENGTH = 'Wrong length';

var addGetter = function (it, key) {
  defineBuiltInAccessor(it, key, {
    configurable: true,
    get: function () {
      return getInternalState(this)[key];
    },
  });
};

var isArrayBuffer = function (it) {
  var klass;
  return isPrototypeOf(ArrayBufferPrototype, it) || (klass = classof(it)) === 'ArrayBuffer' || klass === 'SharedArrayBuffer';
};

var isTypedArrayIndex = function (target, key) {
  return isTypedArray(target)
    && !isSymbol(key)
    && key in target
    && isIntegralNumber(+key)
    && key >= 0;
};

var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
  key = toPropertyKey(key);
  return isTypedArrayIndex(target, key)
    ? createPropertyDescriptor(2, target[key])
    : nativeGetOwnPropertyDescriptor(target, key);
};

var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
  key = toPropertyKey(key);
  if (isTypedArrayIndex(target, key)
    && isObject(descriptor)
    && hasOwn(descriptor, 'value')
    && !hasOwn(descriptor, 'get')
    && !hasOwn(descriptor, 'set')
    // TODO: add validation descriptor w/o calling accessors
    && !descriptor.configurable
    && (!hasOwn(descriptor, 'writable') || descriptor.writable)
    && (!hasOwn(descriptor, 'enumerable') || descriptor.enumerable)
  ) {
    target[key] = descriptor.value;
    return target;
  } return nativeDefineProperty(target, key, descriptor);
};

if (!NATIVE_ARRAY_BUFFER_VIEWS) {
  getOwnPropertyDescriptorModule.f = wrappedGetOwnPropertyDescriptor;
  definePropertyModule.f = wrappedDefineProperty;
  addGetter(TypedArrayPrototype, 'buffer');
  addGetter(TypedArrayPrototype, 'byteOffset');
  addGetter(TypedArrayPrototype, 'byteLength');
  addGetter(TypedArrayPrototype, 'length');
}

$({ target: 'Object', stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {
  getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
  defineProperty: wrappedDefineProperty,
});

module.exports = function (TYPE, wrapper, CLAMPED) {
  var BYTES = TYPE.match(/\d+/)[0] / 8;
  var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';
  var GETTER = 'get' + TYPE;
  var SETTER = 'set' + TYPE;
  var NativeTypedArrayConstructor = globalThis[CONSTRUCTOR_NAME];
  var TypedArrayConstructor = NativeTypedArrayConstructor;
  var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
  var exported = {};

  var getter = function (that, index) {
    var data = getInternalState(that);
    return data.view[GETTER](index * BYTES + data.byteOffset, true);
  };

  var setter = function (that, index, value) {
    var data = getInternalState(that);
    data.view[SETTER](index * BYTES + data.byteOffset, CLAMPED ? toUint8Clamped(value) : value, true);
  };

  var addElement = function (that, index) {
    nativeDefineProperty(that, index, {
      get: function () {
        return getter(this, index);
      },
      set: function (value) {
        return setter(this, index, value);
      },
      enumerable: true,
    });
  };

  if (!NATIVE_ARRAY_BUFFER_VIEWS) {
    TypedArrayConstructor = wrapper(function (that, data, offset, $length) {
      anInstance(that, TypedArrayConstructorPrototype);
      var index = 0;
      var byteOffset = 0;
      var buffer, byteLength, length;
      if (!isObject(data)) {
        length = toIndex(data);
        byteLength = length * BYTES;
        buffer = new ArrayBuffer(byteLength);
      } else if (isArrayBuffer(data)) {
        buffer = data;
        byteOffset = toOffset(offset, BYTES);
        var $len = data.byteLength;
        if ($length === undefined) {
          if ($len % BYTES) throw new RangeError(WRONG_LENGTH);
          byteLength = $len - byteOffset;
          if (byteLength < 0) throw new RangeError(WRONG_LENGTH);
        } else {
          byteLength = toLength($length) * BYTES;
          if (byteLength + byteOffset > $len) throw new RangeError(WRONG_LENGTH);
        }
        length = byteLength / BYTES;
      } else if (isTypedArray(data)) {
        return arrayFromConstructorAndList(TypedArrayConstructor, data);
      } else {
        return call(typedArrayFrom, TypedArrayConstructor, data);
      }
      setInternalState(that, {
        buffer: buffer,
        byteOffset: byteOffset,
        byteLength: byteLength,
        length: length,
        view: new DataView(buffer),
      });
      while (index < length) addElement(that, index++);
    });

    if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
    TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = create(TypedArrayPrototype);
  } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS) {
    TypedArrayConstructor = wrapper(function (dummy, data, typedArrayOffset, $length) {
      anInstance(dummy, TypedArrayConstructorPrototype);
      return inheritIfRequired(function () {
        if (!isObject(data)) return new NativeTypedArrayConstructor(toIndex(data));
        if (isArrayBuffer(data)) return $length !== undefined
          ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length)
          : typedArrayOffset !== undefined
            ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES))
            : new NativeTypedArrayConstructor(data);
        if (isTypedArray(data)) return arrayFromConstructorAndList(TypedArrayConstructor, data);
        return call(typedArrayFrom, TypedArrayConstructor, data);
      }(), dummy, TypedArrayConstructor);
    });

    if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
    forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function (key) {
      if (!(key in TypedArrayConstructor)) {
        createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
      }
    });
    TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
  }

  if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
    createNonEnumerableProperty(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);
  }

  enforceInternalState(TypedArrayConstructorPrototype).TypedArrayConstructor = TypedArrayConstructor;

  if (TYPED_ARRAY_TAG) {
    createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
  }

  var FORCED = TypedArrayConstructor !== NativeTypedArrayConstructor;

  exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;

  $({ global: true, constructor: true, forced: FORCED, sham: !NATIVE_ARRAY_BUFFER_VIEWS }, exported);

  if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
    createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
  }

  if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
    createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
  }

  setSpecies(CONSTRUCTOR_NAME);
};
